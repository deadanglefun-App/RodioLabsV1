#!/usr/bin/env python3
"""
Tests du consensus multi-n≈ìuds RODIO
Valide le comportement du consensus dans diff√©rents sc√©narios
"""

import asyncio
import aiohttp
import json
import time
import logging
from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class NodeInfo:
    """Informations d'un n≈ìud RODIO"""
    node_id: str
    url: str
    status: str = "unknown"
    last_response_time: float = 0.0

class ConsensusTestSuite:
    """Suite de tests pour le consensus RODIO"""
    
    def __init__(self):
        self.nodes = [
            NodeInfo("GATEWAY_01", "http://localhost:8081"),
            NodeInfo("GATEWAY_02", "http://localhost:8082"),
            NodeInfo("GATEWAY_03", "http://localhost:8083"),
        ]
        
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
        self.test_results = []
    
    async def check_nodes_health(self) -> bool:
        """V√©rifie que tous les n≈ìuds sont op√©rationnels"""
        self.logger.info("üîç V√©rification de la sant√© des n≈ìuds...")
        
        healthy_nodes = 0
        
        async with aiohttp.ClientSession() as session:
            for node in self.nodes:
                try:
                    start_time = time.time()
                    async with session.get(f"{node.url}/health", timeout=5) as response:
                        if response.status == 200:
                            data = await response.json()
                            node.status = data.get('status', 'unknown')
                            node.last_response_time = time.time() - start_time
                            
                            if node.status == 'healthy':
                                healthy_nodes += 1
                                self.logger.info(f"‚úÖ {node.node_id}: {node.status} ({node.last_response_time:.3f}s)")
                            else:
                                self.logger.warning(f"‚ö†Ô∏è {node.node_id}: {node.status}")
                        else:
                            node.status = f"http_{response.status}"
                            self.logger.error(f"‚ùå {node.node_id}: HTTP {response.status}")
                            
                except Exception as e:
                    node.status = "unreachable"
                    self.logger.error(f"‚ùå {node.node_id}: {str(e)}")
        
        success = healthy_nodes >= 3
        self.logger.info(f"üìä N≈ìuds sains: {healthy_nodes}/{len(self.nodes)}")
        return success
    
    async def test_normal_consensus(self) -> bool:
        """Test du consensus avec des valeurs coh√©rentes"""
        self.logger.info("üß™ Test: Consensus normal avec valeurs coh√©rentes")
        
        # Simulation de donn√©es coh√©rentes
        test_data = {
            "sensor_id": "temp_test_01",
            "readings": [
                {"node_id": "GATEWAY_01", "value": 23.1, "timestamp": int(time.time())},
                {"node_id": "GATEWAY_02", "value": 23.3, "timestamp": int(time.time())},
                {"node_id": "GATEWAY_03", "value": 23.2, "timestamp": int(time.time())},
            ]
        }
        
        try:
            # Envoi des donn√©es √† chaque n≈ìud
            async with aiohttp.ClientSession() as session:
                tasks = []
                for i, node in enumerate(self.nodes):
                    reading = test_data["readings"][i]
                    task = self._send_sensor_data(session, node, reading)
                    tasks.append(task)
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # V√©rification des r√©sultats
            successful_submissions = sum(1 for r in results if r is True)
            
            if successful_submissions >= 3:
                self.logger.info("‚úÖ Consensus normal: SUCC√àS")
                return True
            else:
                self.logger.error(f"‚ùå Consensus normal: √âCHEC ({successful_submissions}/3)")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur test consensus normal: {e}")
            return False
    
    async def test_outlier_handling(self) -> bool:
        """Test de gestion des outliers"""
        self.logger.info("üß™ Test: Gestion des outliers")
        
        # Simulation avec un outlier
        test_data = {
            "sensor_id": "temp_test_02",
            "readings": [
                {"node_id": "GATEWAY_01", "value": 23.1, "timestamp": int(time.time())},
                {"node_id": "GATEWAY_02", "value": 50.0, "timestamp": int(time.time())},  # Outlier
                {"node_id": "GATEWAY_03", "value": 23.2, "timestamp": int(time.time())},
            ]
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                tasks = []
                for i, node in enumerate(self.nodes):
                    reading = test_data["readings"][i]
                    task = self._send_sensor_data(session, node, reading)
                    tasks.append(task)
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Le consensus devrait filtrer l'outlier
            successful_submissions = sum(1 for r in results if r is True)
            
            if successful_submissions >= 2:  # Au moins 2 n≈ìuds d'accord
                self.logger.info("‚úÖ Gestion outliers: SUCC√àS")
                return True
            else:
                self.logger.error("‚ùå Gestion outliers: √âCHEC")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur test outliers: {e}")
            return False
    
    async def test_node_failure_resilience(self) -> bool:
        """Test de r√©silience √† la panne d'un n≈ìud"""
        self.logger.info("üß™ Test: R√©silience √† la panne d'un n≈ìud")
        
        # Test avec seulement 2 n≈ìuds (simulation de panne du 3√®me)
        active_nodes = self.nodes[:2]
        
        test_data = {
            "sensor_id": "temp_test_03",
            "readings": [
                {"node_id": "GATEWAY_01", "value": 23.1, "timestamp": int(time.time())},
                {"node_id": "GATEWAY_02", "value": 23.3, "timestamp": int(time.time())},
            ]
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                tasks = []
                for i, node in enumerate(active_nodes):
                    reading = test_data["readings"][i]
                    task = self._send_sensor_data(session, node, reading)
                    tasks.append(task)
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Avec 2 n≈ìuds, le consensus devrait √©chouer (minimum 3 requis)
            successful_submissions = sum(1 for r in results if r is True)
            
            if successful_submissions < 3:
                self.logger.info("‚úÖ R√©silience panne: SUCC√àS (consensus refus√© avec <3 n≈ìuds)")
                return True
            else:
                self.logger.error("‚ùå R√©silience panne: √âCHEC (consensus accept√© avec <3 n≈ìuds)")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur test r√©silience: {e}")
            return False
    
    async def test_consensus_timing(self) -> bool:
        """Test des performances temporelles du consensus"""
        self.logger.info("üß™ Test: Performance temporelle du consensus")
        
        start_time = time.time()
        
        test_data = {
            "sensor_id": "temp_test_04",
            "readings": [
                {"node_id": "GATEWAY_01", "value": 23.1, "timestamp": int(time.time())},
                {"node_id": "GATEWAY_02", "value": 23.2, "timestamp": int(time.time())},
                {"node_id": "GATEWAY_03", "value": 23.0, "timestamp": int(time.time())},
            ]
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                tasks = []
                for i, node in enumerate(self.nodes):
                    reading = test_data["readings"][i]
                    task = self._send_sensor_data(session, node, reading)
                    tasks.append(task)
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
            
            consensus_time = time.time() - start_time
            
            # Le consensus devrait prendre moins de 5 secondes
            if consensus_time < 5.0:
                self.logger.info(f"‚úÖ Performance consensus: SUCC√àS ({consensus_time:.3f}s)")
                return True
            else:
                self.logger.warning(f"‚ö†Ô∏è Performance consensus: LENT ({consensus_time:.3f}s)")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur test performance: {e}")
            return False
    
    async def _send_sensor_data(self, session: aiohttp.ClientSession, node: NodeInfo, reading: Dict) -> bool:
        """Envoie des donn√©es de capteur √† un n≈ìud"""
        try:
            async with session.post(
                f"{node.url}/api/sensor-data",
                json=reading,
                timeout=3
            ) as response:
                return response.status == 200
        except Exception as e:
            self.logger.debug(f"Erreur envoi donn√©es √† {node.node_id}: {e}")
            return False
    
    async def get_consensus_metrics(self) -> Dict[str, Any]:
        """R√©cup√®re les m√©triques de consensus de tous les n≈ìuds"""
        metrics = {}
        
        async with aiohttp.ClientSession() as session:
            for node in self.nodes:
                try:
                    async with session.get(f"{node.url}/metrics", timeout=3) as response:
                        if response.status == 200:
                            text = await response.text()
                            metrics[node.node_id] = self._parse_prometheus_metrics(text)
                except Exception as e:
                    self.logger.debug(f"Erreur m√©triques {node.node_id}: {e}")
        
        return metrics
    
    def _parse_prometheus_metrics(self, metrics_text: str) -> Dict[str, float]:
        """Parse simple des m√©triques Prometheus"""
        metrics = {}
        for line in metrics_text.split('\n'):
            if line.startswith('rodio_consensus_success_rate'):
                try:
                    value = float(line.split()[-1])
                    metrics['consensus_success_rate'] = value
                except:
                    pass
            elif line.startswith('rodio_sensor_readings_total'):
                try:
                    value = float(line.split()[-1])
                    metrics['sensor_readings_total'] = value
                except:
                    pass
        return metrics
    
    async def run_full_test_suite(self) -> Dict[str, Any]:
        """Ex√©cute la suite compl√®te de tests"""
        self.logger.info("üöÄ D√©marrage de la suite de tests consensus RODIO")
        self.logger.info("=" * 60)
        
        results = {
            "timestamp": int(time.time()),
            "total_tests": 0,
            "passed_tests": 0,
            "failed_tests": 0,
            "test_details": []
        }
        
        # Liste des tests √† ex√©cuter
        tests = [
            ("health_check", self.check_nodes_health),
            ("normal_consensus", self.test_normal_consensus),
            ("outlier_handling", self.test_outlier_handling),
            ("node_failure_resilience", self.test_node_failure_resilience),
            ("consensus_timing", self.test_consensus_timing),
        ]
        
        for test_name, test_func in tests:
            self.logger.info(f"\nüìã Ex√©cution: {test_name}")
            
            try:
                start_time = time.time()
                success = await test_func()
                duration = time.time() - start_time
                
                results["total_tests"] += 1
                if success:
                    results["passed_tests"] += 1
                else:
                    results["failed_tests"] += 1
                
                results["test_details"].append({
                    "name": test_name,
                    "success": success,
                    "duration": round(duration, 3)
                })
                
            except Exception as e:
                self.logger.error(f"‚ùå Erreur critique dans {test_name}: {e}")
                results["total_tests"] += 1
                results["failed_tests"] += 1
                results["test_details"].append({
                    "name": test_name,
                    "success": False,
                    "error": str(e)
                })
        
        # R√©cup√©ration des m√©triques finales
        try:
            final_metrics = await self.get_consensus_metrics()
            results["final_metrics"] = final_metrics
        except Exception as e:
            self.logger.warning(f"Impossible de r√©cup√©rer les m√©triques finales: {e}")
        
        # Rapport final
        self.logger.info("\n" + "=" * 60)
        self.logger.info("üìä RAPPORT FINAL DES TESTS")
        self.logger.info("=" * 60)
        self.logger.info(f"Tests ex√©cut√©s: {results['total_tests']}")
        self.logger.info(f"Tests r√©ussis: {results['passed_tests']}")
        self.logger.info(f"Tests √©chou√©s: {results['failed_tests']}")
        
        success_rate = (results['passed_tests'] / results['total_tests']) * 100 if results['total_tests'] > 0 else 0
        self.logger.info(f"Taux de r√©ussite: {success_rate:.1f}%")
        
        if success_rate >= 80:
            self.logger.info("üéâ CONSENSUS RODIO: VALIDATION R√âUSSIE!")
        else:
            self.logger.error("‚ùå CONSENSUS RODIO: PROBL√àMES D√âTECT√âS")
        
        return results

async def main():
    """Point d'entr√©e principal"""
    test_suite = ConsensusTestSuite()
    
    try:
        results = await test_suite.run_full_test_suite()
        
        # Sauvegarde des r√©sultats
        with open(f"consensus_test_results_{int(time.time())}.json", "w") as f:
            json.dump(results, f, indent=2)
        
        return results["passed_tests"] == results["total_tests"]
        
    except KeyboardInterrupt:
        print("\nüõë Tests interrompus par l'utilisateur")
        return False
    except Exception as e:
        print(f"‚ùå Erreur critique: {e}")
        return False

if __name__ == "__main__":
    success = asyncio.run(main())
    exit(0 if success else 1)